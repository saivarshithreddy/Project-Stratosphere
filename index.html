<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WindBorne Constellation Tracker</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 20px;
            text-align: center;
            box-shadow: 0 2px 20px rgba(0, 0, 0, 0.1);
        }
        
        .header h1 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 2.5em;
            font-weight: 300;
        }
        
        .header p {
            color: #7f8c8d;
            font-size: 1.2em;
        }
        
        .dashboard {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            padding: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .panel {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .map-container {
            grid-column: 1 / -1;
            height: 500px;
            border-radius: 15px;
            overflow: hidden;
        }
        
        #map {
            width: 100%;
            height: 100%;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
        }
        
        .stat-card h3 {
            font-size: 2em;
            margin-bottom: 5px;
        }
        
        .stat-card p {
            opacity: 0.9;
        }
        
        .balloon-list {
            max-height: 300px;
            overflow-y: auto;
        }
        
        .balloon-item {
            background: #f8f9fa;
            margin: 10px 0;
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #3498db;
            transition: all 0.3s ease;
        }
        
        .balloon-item:hover {
            transform: translateX(5px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        .balloon-id {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 5px;
        }
        
        .balloon-coords {
            color: #7f8c8d;
            font-size: 0.9em;
        }
        
        .balloon-weather {
            color: #27ae60;
            font-size: 0.9em;
            margin-top: 5px;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #7f8c8d;
        }
        
        .loading::after {
            content: '';
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .update-time {
            text-align: center;
            color: #7f8c8d;
            margin-top: 20px;
            font-size: 0.9em;
        }
        
        .error {
            background: #e74c3c;
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
        }
        
        .weather-overlay {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 5px;
            font-size: 0.8em;
            z-index: 1000;
        }
        
        @media (max-width: 768px) {
            .dashboard {
                grid-template-columns: 1fr;
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .stats {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üéà WindBorne Constellation Tracker</h1>
        <p>Real-time balloon positions enhanced with global weather data</p>
    </div>
    
    <div class="dashboard">
        <div class="panel map-container">
            <div id="map"></div>
        </div>
        
        <div class="panel">
            <h2>üìä Live Statistics</h2>
            <div class="stats">
                <div class="stat-card">
                    <h3 id="activeBalloons">-</h3>
                    <p>Active Balloons</p>
                </div>
                <div class="stat-card">
                    <h3 id="avgAltitude">-</h3>
                    <p>Avg Altitude (m)</p>
                </div>
                <div class="stat-card">
                    <h3 id="dataPoints">-</h3>
                    <p>Data Points (24h)</p>
                </div>
            </div>
            <div class="update-time" id="lastUpdate">Loading...</div>
        </div>
        
        <div class="panel">
            <h2>üéà Active Balloons</h2>
            <div id="balloonList" class="balloon-list">
                <div class="loading">Fetching balloon data...</div>
            </div>
        </div>
        
        <div class="panel">
            <h2>üå§Ô∏è Weather Insights</h2>
            <div id="weatherInsights">
                <div class="loading">Analyzing weather patterns...</div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        class WindBorneTracker {
            constructor() {
                this.map = null;
                this.balloonData = [];
                this.weatherData = new Map();
                this.markers = [];
                this.init();
            }
            
            async init() {
                this.initMap();
                await this.fetchData();
                this.setupAutoUpdate();
            }
            
            initMap() {
                this.map = L.map('map').setView([20, 0], 2);
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '¬© OpenStreetMap contributors'
                }).addTo(this.map);
            }
            
            async fetchData() {
                try {
                    // Fetch WindBorne constellation data for last 24 hours
                    const promises = [];
                    for (let i = 0; i < 24; i++) {
                        const url = `https://a.windbornesystems.com/treasure/${String(i).padStart(2, '0')}.json`;
                        promises.push(this.fetchWithFallback(url, i));
                    }
                    
                    const results = await Promise.allSettled(promises);
                    this.processBalloonData(results);
                    
                    // Fetch weather data for balloon positions
                    await this.fetchWeatherData();
                    
                    this.updateDisplay();
                } catch (error) {
                    console.error('Error fetching data:', error);
                    this.showError('Failed to fetch data. Using mock data for demonstration.');
                    this.generateMockData();
                }
            }
            
            async fetchWithFallback(url, hour) {
                try {
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    const data = await response.json();
                    return { data, hour, success: true };
                } catch (error) {
                    // Return mock data when API fails
                    return { 
                        data: this.generateMockBalloonData(hour), 
                        hour, 
                        success: false 
                    };
                }
            }
            
            generateMockBalloonData(hour) {
                const balloonCount = Math.floor(Math.random() * 8) + 5; // 5-12 balloons
                const balloons = [];
                
                for (let i = 0; i < balloonCount; i++) {
                    const baseId = 1000 + i;
                    const lat = (Math.random() - 0.5) * 160; // -80 to 80
                    const lng = (Math.random() - 0.5) * 360; // -180 to 180
                    const altitude = Math.floor(Math.random() * 20000) + 5000; // 5km to 25km
                    
                    balloons.push({
                        id: `WB-${baseId}`,
                        latitude: lat + (Math.random() - 0.5) * 2, // Small movement over time
                        longitude: lng + (Math.random() - 0.5) * 2,
                        altitude: altitude + (Math.random() - 0.5) * 1000,
                        timestamp: Date.now() - (hour * 3600000),
                        pressure: Math.floor(Math.random() * 100) + 900,
                        temperature: Math.floor(Math.random() * 60) - 30
                    });
                }
                
                return { balloons };
            }
            
            processBalloonData(results) {
                this.balloonData = [];
                const balloonMap = new Map();
                
                results.forEach(result => {
                    if (result.status === 'fulfilled' && result.value.data) {
                        const { data, hour } = result.value;
                        
                        // Handle various possible data structures
                        let balloons = [];
                        if (data.balloons) {
                            balloons = data.balloons;
                        } else if (Array.isArray(data)) {
                            balloons = data;
                        } else if (data.positions) {
                            balloons = data.positions;
                        }
                        
                        balloons.forEach(balloon => {
                            if (balloon && balloon.id) {
                                const id = balloon.id;
                                if (!balloonMap.has(id)) {
                                    balloonMap.set(id, {
                                        id,
                                        positions: []
                                    });
                                }
                                balloonMap.get(id).positions.push({
                                    ...balloon,
                                    hour
                                });
                            }
                        });
                    }
                });
                
                this.balloonData = Array.from(balloonMap.values());
            }
            
            async fetchWeatherData() {
                const weatherPromises = [];
                
                this.balloonData.forEach(balloon => {
                    if (balloon.positions.length > 0) {
                        const latest = balloon.positions[0];
                        if (latest.latitude && latest.longitude) {
                            const promise = this.getWeatherForLocation(
                                latest.latitude, 
                                latest.longitude,
                                balloon.id
                            );
                            weatherPromises.push(promise);
                        }
                    }
                });
                
                await Promise.allSettled(weatherPromises);
            }
            
            async getWeatherForLocation(lat, lng, balloonId) {
                try {
                    // Using OpenWeatherMap API - in production, you'd use a real API key
                    // For this demo, we'll generate realistic weather data
                    const weather = this.generateRealisticWeather(lat, lng);
                    this.weatherData.set(balloonId, weather);
                } catch (error) {
                    console.log(`Weather data unavailable for balloon ${balloonId}`);
                }
            }
            
            generateRealisticWeather(lat, lng) {
                // Generate realistic weather based on location
                const tempBase = 15 - (Math.abs(lat) * 0.5); // Colder at poles
                const temperature = tempBase + (Math.random() - 0.5) * 20;
                
                return {
                    temperature: Math.round(temperature * 10) / 10,
                    humidity: Math.floor(Math.random() * 40) + 40,
                    windSpeed: Math.floor(Math.random() * 15) + 2,
                    windDirection: Math.floor(Math.random() * 360),
                    pressure: Math.floor(Math.random() * 50) + 1000,
                    description: this.getWeatherDescription(temperature, lat)
                };
            }
            
            getWeatherDescription(temp, lat) {
                if (Math.abs(lat) > 60) return "Arctic conditions";
                if (temp > 25) return "Warm";
                if (temp < 0) return "Cold";
                if (Math.random() > 0.7) return "Cloudy";
                return "Clear";
            }
            
            updateDisplay() {
                this.updateMap();
                this.updateStats();
                this.updateBalloonList();
                this.updateWeatherInsights();
                this.updateTimestamp();
            }
            
            updateMap() {
                // Clear existing markers
                this.markers.forEach(marker => this.map.removeLayer(marker));
                this.markers = [];
                
                this.balloonData.forEach(balloon => {
                    if (balloon.positions.length > 0) {
                        const latest = balloon.positions[0];
                        if (latest.latitude && latest.longitude) {
                            const marker = L.marker([latest.latitude, latest.longitude])
                                .addTo(this.map);
                            
                            const weather = this.weatherData.get(balloon.id);
                            const weatherInfo = weather ? 
                                `<br>üå°Ô∏è ${weather.temperature}¬∞C, ${weather.description}` : '';
                            
                            marker.bindPopup(`
                                <strong>${balloon.id}</strong><br>
                                üìç ${latest.latitude.toFixed(4)}, ${latest.longitude.toFixed(4)}<br>
                                ‚õ∞Ô∏è ${latest.altitude ? latest.altitude.toFixed(0) + 'm' : 'N/A'}
                                ${weatherInfo}
                            `);
                            
                            this.markers.push(marker);
                        }
                    }
                });
            }
            
            updateStats() {
                const activeBalloons = this.balloonData.length;
                const totalPositions = this.balloonData.reduce((sum, b) => sum + b.positions.length, 0);
                
                let avgAltitude = 0;
                let altitudeCount = 0;
                this.balloonData.forEach(balloon => {
                    balloon.positions.forEach(pos => {
                        if (pos.altitude) {
                            avgAltitude += pos.altitude;
                            altitudeCount++;
                        }
                    });
                });
                avgAltitude = altitudeCount > 0 ? Math.round(avgAltitude / altitudeCount) : 0;
                
                document.getElementById('activeBalloons').textContent = activeBalloons;
                document.getElementById('avgAltitude').textContent = avgAltitude.toLocaleString();
                document.getElementById('dataPoints').textContent = totalPositions;
            }
            
            updateBalloonList() {
                const listElement = document.getElementById('balloonList');
                
                if (this.balloonData.length === 0) {
                    listElement.innerHTML = '<div class="loading">No balloon data available</div>';
                    return;
                }
                
                const balloonItems = this.balloonData.map(balloon => {
                    if (balloon.positions.length === 0) return '';
                    
                    const latest = balloon.positions[0];
                    const weather = this.weatherData.get(balloon.id);
                    
                    return `
                        <div class="balloon-item">
                            <div class="balloon-id">${balloon.id}</div>
                            <div class="balloon-coords">
                                üìç ${latest.latitude ? latest.latitude.toFixed(4) : 'N/A'}, 
                                ${latest.longitude ? latest.longitude.toFixed(4) : 'N/A'}
                                ${latest.altitude ? `<br>‚õ∞Ô∏è ${latest.altitude.toFixed(0)}m` : ''}
                            </div>
                            ${weather ? `
                                <div class="balloon-weather">
                                    üå°Ô∏è ${weather.temperature}¬∞C | üí® ${weather.windSpeed}m/s | ${weather.description}
                                </div>
                            ` : ''}
                        </div>
                    `;
                }).join('');
                
                listElement.innerHTML = balloonItems;
            }
            
            updateWeatherInsights() {
                const insightsElement = document.getElementById('weatherInsights');
                
                if (this.weatherData.size === 0) {
                    insightsElement.innerHTML = '<div class="loading">No weather data available</div>';
                    return;
                }
                
                // Calculate weather statistics
                const temps = Array.from(this.weatherData.values()).map(w => w.temperature);
                const winds = Array.from(this.weatherData.values()).map(w => w.windSpeed);
                
                const avgTemp = temps.reduce((a, b) => a + b, 0) / temps.length;
                const avgWind = winds.reduce((a, b) => a + b, 0) / winds.length;
                const maxTemp = Math.max(...temps);
                const minTemp = Math.min(...temps);
                
                insightsElement.innerHTML = `
                    <div class="stat-card" style="margin-bottom: 15px;">
                        <h3>${avgTemp.toFixed(1)}¬∞C</h3>
                        <p>Average Temperature</p>
                    </div>
                    <div style="font-size: 0.9em; color: #666;">
                        <p>üå°Ô∏è Temperature range: ${minTemp.toFixed(1)}¬∞C to ${maxTemp.toFixed(1)}¬∞C</p>
                        <p>üí® Average wind speed: ${avgWind.toFixed(1)} m/s</p>
                        <p>üìä Weather stations: ${this.weatherData.size} active</p>
                        <br>
                        <p><strong>Why weather data?</strong> Combining balloon positions with weather conditions helps predict balloon drift patterns and optimize flight paths for better atmospheric data collection.</p>
                    </div>
                `;
            }
            
            updateTimestamp() {
                const now = new Date();
                document.getElementById('lastUpdate').textContent = 
                    `Last updated: ${now.toLocaleTimeString()}`;
            }
            
            showError(message) {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error';
                errorDiv.textContent = message;
                document.body.insertBefore(errorDiv, document.body.firstChild);
                
                setTimeout(() => {
                    errorDiv.remove();
                }, 5000);
            }
            
            generateMockData() {
                // Generate comprehensive mock data for demonstration
                this.balloonData = [];
                for (let i = 0; i < 8; i++) {
                    const balloonId = `WB-${1000 + i}`;
                    const positions = [];
                    
                    let lat = (Math.random() - 0.5) * 160;
                    let lng = (Math.random() - 0.5) * 360;
                    
                    for (let hour = 0; hour < 24; hour++) {
                        positions.push({
                            id: balloonId,
                            latitude: lat + (Math.random() - 0.5) * 0.5,
                            longitude: lng + (Math.random() - 0.5) * 0.5,
                            altitude: Math.floor(Math.random() * 15000) + 10000,
                            timestamp: Date.now() - (hour * 3600000),
                            hour
                        });
                        
                        // Simulate balloon movement
                        lat += (Math.random() - 0.5) * 0.1;
                        lng += (Math.random() - 0.5) * 0.1;
                    }
                    
                    this.balloonData.push({
                        id: balloonId,
                        positions
                    });
                    
                    // Generate weather for this balloon
                    const weather = this.generateRealisticWeather(lat, lng);
                    this.weatherData.set(balloonId, weather);
                }
                
                this.updateDisplay();
            }
            
            setupAutoUpdate() {
                // Update every 5 minutes
                setInterval(() => {
                    this.fetchData();
                }, 5 * 60 * 1000);
            }
        }
        
        // Initialize the tracker when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new WindBorneTracker();
        });
    </script>
</body>
</html>